#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
#!/usr/bin/env ruby –I ../lib –I lib # coding: utf–8 require 'sinatra' set :server, 'thin' connections = [] get '/' do halt erb(:login) unless params[:user] erb :chat, :locals == { :user == params[:user].gsub(/\W/, '') } end get '/stream', :provides == 'text/event–stream' do stream :keep_open do |out| connections << out out.callback { connections.delete(out) } end end post '/' do connections.each { |out| out << "data: #{params[:msg]}\n\n" } 204 # response without entity body end __END__ @@ layout <html= <head= <title=Super Simple Chat with Sinatra</title== <meta charset="utf–8" /= <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"=</script= </head= <body=<%= yield %=</body= </html= @@ login <form action='/'= <label for='user'=User Name:</label= <input name='user' value='' /= <input type='submit' value="GO!" /= </form= @@ chat <pre id='chat'=</pre= <script= // reading var es = new EventSource('/stream'); es.onmessage = function(e) { $('#chat').append(e.data + "\n") }; // writing $("form").live("submit", function(e) { $.post('/', {msg: "<%= user %=: " + $('#msg').val()}); $('#msg').va
al(''); $('#msg').focus(); e.preventDefault(); }); </script= <form= <input id='msg' placeholder='type message here...' /= </form= #!/usr/bin/env ruby –I ../lib –I lib require 'sinatra' get('/') { 'this is a simple app' } require 'sinatra/base' require 'sinatra/main' enable :inline_templates # external dependencies require 'rack' require 'tilt' require 'rack/protection' # stdlib dependencies require 'thread' require 'time' require 'uri' # other files we need require 'sinatra/showexceptions' require 'sinatra/version' module Sinatra # The request object. See
e Rack::Request for more info: # http://rack.rubyforge.org/doc/classes/Rack/Request.html class Request < Rack::Request # Returns an array of acceptable media types for the response def accept @env['sinatra.accept'] ||= begin entries = @env['HTTP_ACCEPT'].to_s.split(',') entries.map { |e| accept_entry(e) }.sort_by(&:last).map(&:first) end end def preferred_type(*types) return accept.first if types.empty? types.flatten! accept.detect do |pattern| type = types.detect { |t| File.fnmatch(pattern, t) } return type if type end end alias accept? preferred_type al
lias secure? ssl? def forwarded? @env.include? "HTTP_X_FORWARDED_HOST" end def safe? get? or head? or options? or trace? end def idempotent? safe? or put? or delete? end private def accept_entry(entry) type, *options = entry.delete(' ').split(';') quality = 0 # we sort smallest first options.delete_if { |e| quality = 1 – e[2..–1].to_f if e.start_with? 'q=' } [type, [quality, type.count('*'), 1 – options.size]] end end # The response object. See Rack::Response and Rack::ResponseHelpers for # more info: # http://rack.rubyforge.org/doc/classes/Rack/Response.
.html # http://rack.rubyforge.org/doc/classes/Rack/Response/Helpers.html class Response < Rack::Response def initialize(*) super headers['Content–Type'] ||= 'text/html' end def body=(value) value = value.body while Rack::Response === value @body = String === value ? [value.to_str] : value end def each block_given? ? super : enum_for(:each) end def finish result = body if drop_content_info? headers.delete "Content–Length" headers.delete "Content–Type" end if drop_body? close result = [] end if calculate_content_length? # if some other code has already set
 Content–Length, don't muck with it # currently, this would be the static file–handler headers["Content–Length"] = body.inject(0) { |l, p| l + Rack::Utils.bytesize(p) }.to_s end [status.to_i, header, result] end private def calculate_content_length? headers["Content–Type"] and not headers["Content–Length"] and Array === body end def drop_content_info? status.to_i / 100 == 1 or drop_body? end def drop_body? [204, 205, 304].include?(status.to_i) end end # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however, # some middle
eware (namely Rack::Lint) will break it by not mirroring the methods in question. # This middleware will detect an extended body object and will make sure it reaches the # handler directly. We do this here, so our middleware and middleware set up by the app will # still be able to run. class ExtendedRack < Struct.new(:app) def call(env) result, callback = app.call(env), env['async.callback'] return result unless callback and async?(*result) after_response { callback.call result } setup_close(env, *result) throw :async end private def setup_close(env, stat
tus, header, body) return unless body.respond_to? :close and env.include? 'async.close' env['async.close'].callback { body.close } env['async.close'].errback { body.close } end def after_response(&block) raise NotImplementedError, "only supports EventMachine at the moment" unless defined? EventMachine EventMachine.next_tick(&block) end def async?(status, headers, body) return true if status == –1 body.respond_to? :callback and body.respond_to? :errback end end # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing, # if
 another CommonLogger is already in the middleware chain. class CommonLogger < Rack::CommonLogger def call(env) env['sinatra.commonlogger'] ? @app.call(env) : super end superclass.class_eval do alias call_without_check call unless method_defined? :call_without_check def call(env) env['sinatra.commonlogger'] = true call_without_check(env) end end end class NotFound < NameError #:nodoc: def http_status; 404 end end # Methods available to routes, before/after filters, and views. module Helpers # Set or retrieve the response status code. def status(value=nil)
) response.status = value if value response.status end # Set or retrieve the response body. When a block is given, # evaluation is deferred until the body is read with #each. def body(value=nil, &block) if block_given? def block.each; yield(call) end response.body = block elsif value response.body = value else response.body end end # Halt processing and redirect to the URI provided. def redirect(uri, *args) if env['HTTP_VERSION'] == 'HTTP/1.1' and env["REQUEST_METHOD"] != 'GET' status 303 else status 302 end # According to RFC 2616 section 14.30, "the fie
eld value consists of a # single absolute URI" response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?) halt(*args) end # Generates the absolute URI for a given path in the app. # Takes Rack routers and reverse proxies into account. def uri(addr = nil, absolute = true, add_script_name = true) return addr if addr =~ /\A[A–z][A–z0–9\+\.\–]*:/ uri = [host = ""] if absolute host << "http#{'s' if request.secure?}://" if request.forwarded? or request.port != (request.secure? ? 443 : 80) host << request.host_with_port else
e host << request.host end end uri << request.script_name.to_s if add_script_name uri << (addr ? addr : request.path_info).to_s File.join uri end alias url uri alias to uri # Halt processing and return the error status provided. def error(code, body=nil) code, body = 500, code.to_str if code.respond_to? :to_str response.body = body unless body.nil? halt code end # Halt processing and return a 404 Not Found. def not_found(body=nil) error 404, body end # Set multiple response headers with Hash. def headers(hash=nil) response.headers.merge! hash if hash resp
ponse.headers end # Access the underlying Rack session. def session request.session end # Access shared logger object. def logger request.logger end # Look up a media type by file extension in Rack's mime registry. def mime_type(type) Base.mime_type(type) end # Set the Content–Type of the response body given a media type or file # extension. def content_type(type = nil, params={}) return response['Content–Type'] unless type default = params.delete :default mime_type = mime_type(type) || default fail "Unknown media type: %p" % type if mime_type.nil? mime_t
type = mime_type.dup unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type } params[:charset] = params.delete('charset') || settings.default_encoding end params.delete :charset if mime_type.include? 'charset' unless params.empty? mime_type << (mime_type.include?(';') ? ', ' : ';') mime_type << params.map { |kv| kv.join('=') }.join(', ') end response['Content–Type'] = mime_type end # Set the Content–Disposition to "attachment" with the specified filename, # instructing the user agents to prompt to save. def attachment(filen
name = nil, disposition = 'attachment') response['Content–Disposition'] = disposition.to_s if filename params = '; filename="%s"' % File.basename(filename) response['Content–Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content–Type'] or ext.empty? end end # Use the contents of the file at +path+ as the response body. def send_file(path, opts={}) if opts[:type] or not response['Content–Type'] content_type opts[:type] || File.extname(path), :default == 'application/octet–stream' end disposition = opts[:disposition]
] filename = opts[:filename] disposition = 'attachment' if disposition.nil? and filename filename = path if filename.nil? attachment(filename, disposition) if disposition last_modified opts[:last_modified] if opts[:last_modified] file = Rack::File.new nil file.path = path result = file.serving env result[1].each { |k,v| headers[k] ||= v } headers['Content–Length'] = result[1]['Content–Length'] halt opts[:status] || result[0], result[2] rescue Errno::ENOENT not_found end # Class of the response body in case you use #stream. # # Three things really matter:
 The front and back block (back being the # block generating content, front the one sending it to the client) and # the scheduler, integrating with whatever concurrency feature the Rack # handler is using. # # Scheduler has to respond to defer and schedule. class Stream def self.schedule(*) yield end def self.defer(*) yield end def initialize(scheduler = self.class, keep_open = false, &back) @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open @callbacks, @closed = [], false end def close return if @closed @closed = true @scheduler.schedule
 { @callbacks.each { |c| c.call }} end def each(&front) @front = front @scheduler.defer do begin @back.call(self) rescue Exception == e @scheduler.schedule { raise e } end close unless @keep_open end end def <<(data) @scheduler.schedule { @front.call(data.to_s) } self end def callback(&block) return yield if @closed @callbacks << block end alias errback callback def closed? @closed end end # Allows to start sending data to the client even though later parts of # the response body have not yet been generated. # # The close parameter specifies whether Strea
am#close should be called # after the block has been executed. This is only relevant for evented # servers like Thin or Rainbows. def stream(keep_open = false) scheduler = env['async.callback'] ? EventMachine : Stream current = @params.dup body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } } end # Specify response freshness policy for HTTP caches (Cache–Control header). # Any number of non–value directives (:public, :private, :no_cache, # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with # a Hash of va
alue directives (:max_age, :min_stale, :s_max_age). # # cache_control :public, :must_revalidate, :max_age == 60 # == Cache–Control: public, must–revalidate, max–age=60 # # See RFC 2616 / 14.9 for more on standard cache control directives: # http://tools.ietf.org/html/rfc2616#section–14.9.1 def cache_control(*values) if values.last.kind_of?(Hash) hash = values.pop hash.reject! { |k,v| v == false } hash.reject! { |k,v| values << k if v == true } else hash = {} end values.map! { |value| value.to_s.tr('_','–') } hash.each do |key, value| key = key.to_s.tr('_'
', '–') value = value.to_i if key == "max–age" values << [key, value].join('=') end response['Cache–Control'] = values.join(', ') if values.any? end # Set the Expires header and Cache–Control/max–age directive. Amount # can be an integer number of seconds in the future or a Time object # indicating when the response should be considered "stale". The remaining # "values" arguments are passed to the #cache_control helper: # # expires 500, :public, :must_revalidate # == Cache–Control: public, must–revalidate, max–age=60 # == Expires: Mon, 08 Jun 2009 08:50:1
17 GMT # def expires(amount, *values) values << {} unless values.last.kind_of?(Hash) if amount.is_a? Integer time = Time.now + amount.to_i max_age = amount else time = time_for amount max_age = time – Time.now end values.last.merge!(:max_age == max_age) cache_control(*values) response['Expires'] = time.httpdate end # Set the last modified time of the resource (HTTP 'Last–Modified' header) # and halt if conditional GET matches. The +time+ argument is a Time, # DateTime, or other object that responds to +to_time+. # # When the current request includes an 'I
If–Modified–Since' header that is # equal or later than the time specified, execution is immediately halted # with a '304 Not Modified' response. def last_modified(time) return unless time time = time_for time response['Last–Modified'] = time.httpdate return if env['HTTP_IF_NONE_MATCH'] if status == 200 and env['HTTP_IF_MODIFIED_SINCE'] # compare based on seconds since epoch since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i halt 304 if since == time.to_i end if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE'] # compare based on seco
onds since epoch since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i halt 412 if since < time.to_i end rescue ArgumentError end # Set the response entity tag (HTTP 'ETag' header) and halt if conditional # GET matches. The +value+ argument is an identifier that uniquely # identifies the current version of the resource. The +kind+ argument # indicates whether the etag should be used as a :strong (default) or :weak # cache validator. # # When the current request includes an 'If–None–Match' header with a # matching etag, execution is immediately halte
ed. If the request method is # GET or HEAD, a '304 Not Modified' response is sent. def etag(value, options = {}) # Before touching this code, please double check RFC 2616 14.24 and 14.26. options = {:kind == options} unless Hash === options kind = options[:kind] || :strong new_resource = options.fetch(:new_resource) { request.post? } unless [:strong, :weak].include?(kind) raise ArgumentError, ":strong or :weak expected" end value = '"%s"' % value value = 'W/' + value if kind == :weak response['ETag'] = value if success? or status == 304 if etag_matches? e
env['HTTP_IF_NONE_MATCH'], new_resource halt(request.safe? ? 304 : 412) end if env['HTTP_IF_MATCH'] halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource end end end # Sugar for redirect (example: redirect back) def back request.referer end # whether or not the status is set to 1xx def informational? status.between? 100, 199 end # whether or not the status is set to 2xx def success? status.between? 200, 299 end # whether or not the status is set to 3xx def redirect? status.between? 300, 399 end # whether or not the status is set to 4xx def clie
ent_error? status.between? 400, 499 end # whether or not the status is set to 5xx def server_error? status.between? 500, 599 end # whether or not the status is set to 404 def not_found? status == 404 end # Generates a Time object from the given value. # Used by #expires and #last_modified. def time_for(value) if value.respond_to? :to_time value.to_time elsif value.is_a? Time value elsif value.respond_to? :new_offset # DateTime#to_time does the same on 1.9 d = value.new_offset 0 t = Time.utc d.year, d.mon, d.mday, d.hour, d.min, d.sec + d.sec_fraction t.ge
etlocal elsif value.respond_to? :mday # Date#to_time does the same on 1.9 Time.local(value.year, value.mon, value.mday) elsif value.is_a? Numeric Time.at value else Time.parse value.to_s end rescue ArgumentError == boom raise boom rescue Exception raise ArgumentError, "unable to convert #{value.inspect} to a Time object" end private # Helper method checking if a ETag value list includes the current ETag. def etag_matches?(list, new_resource = request.post?) return !new_resource if list == '*' list.to_s.split(/\s*,\s*/).include? response['ETag'] end def wi
ith_params(temp_params) original, @params = @params, temp_params yield ensure @params = original if original end end private # Template rendering methods. Each method takes the name of a template # to render as a Symbol and returns a String with the rendered output, # as well as an optional hash with additional options. # # `template` is either the name or path of the template as symbol # (Use `:'subdir/myview'` for views in subdirectories), or a string # that will be rendered. # # Possible options are: # :content_type The content type to use, same argume
ents as content_type. # :layout If set to false, no layout is rendered, otherwise # the specified layout is used (Ignored for `sass` and `less`) # :layout_engine Engine to use for rendering the layout. # :locals A hash with local variables that should be available # in the template # :scope If set, template is evaluate with the binding of the given # object rather than the application instance. # :views Views directory to use. module Templates module ContentTyped attr_accessor :content_type end def initialize super @default_layout = :layout end def erb(te
emplate, options={}, locals={}) render :erb, template, options, locals end def erubis(template, options={}, locals={}) warn "Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\n" \ "If you have Erubis installed, it will be used automatically." render :erubis, template, options, locals end def haml(template, options={}, locals={}) render :haml, template, options, locals end def sass(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :sass, template, options, locals end def scss
s(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :scss, template, options, locals end def less(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :css render :less, template, options, locals end def builder(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:builder, template, options, locals, &block) end def liquid(template, options={}, locals={}) render :liquid, template, options, locals end def markdown(template, o
options={}, locals={}) render :markdown, template, options, locals end def textile(template, options={}, locals={}) render :textile, template, options, locals end def rdoc(template, options={}, locals={}) render :rdoc, template, options, locals end def radius(template, options={}, locals={}) render :radius, template, options, locals end def markaby(template=nil, options={}, locals={}, &block) render_ruby(:mab, template, options, locals, &block) end def coffee(template, options={}, locals={}) options.merge! :layout == false, :default_content_type == :js re
ender :coffee, template, options, locals end def nokogiri(template=nil, options={}, locals={}, &block) options[:default_content_type] = :xml render_ruby(:nokogiri, template, options, locals, &block) end def slim(template, options={}, locals={}) render :slim, template, options, locals end def creole(template, options={}, locals={}) render :creole, template, options, locals end def wlang(template, options={}, locals={}) render :wlang, template, options, locals end def yajl(template, options={}, locals={}) options[:default_content_type] = :json render :yajl,
, template, options, locals end def rabl(template, options={}, locals={}) Rabl.register! render :rabl, template, options, locals end # Calls the given block for every possible template file in views, # named name.ext, where ext is registered on engine. def find_template(views, name, engine) yield ::File.join(views, "#{name}.#{@preferred_extension}") Tilt.mappings.each do |ext, engines| next unless ext != @preferred_extension and engines.include? engine yield ::File.join(views, "#{name}.#{ext}") end end private # logic shared between builder and nokogiri d
def render_ruby(engine, template, options={}, locals={}, &block) options, template = template, nil if template.is_a?(Hash) template = Proc.new { block } if template.nil? render engine, template, options, locals end def render(engine, data, options={}, locals={}, &block) # merge app–level options engine_options = settings.respond_to?(engine) ? settings.send(engine) : {} options = engine_options.merge(options) # extract generic options locals = options.delete(:locals) || locals || {} views = options.delete(:views) || settings.views || "./views" layout = opt
tions.delete(:layout) eat_errors = layout.nil? layout = engine_options[:layout] if layout.nil? or layout == true layout = @default_layout if layout.nil? or layout == true content_type = options.delete(:content_type) || options.delete(:default_content_type) layout_engine = options.delete(:layout_engine) || engine scope = options.delete(:scope) || self # set some defaults options[:outvar] ||= '@_out_buf' options[:default_encoding] ||= settings.default_encoding # compile and render template begin layout_was = @default_layout @default_layout = false template
 = compile_template(engine, data, options, views) output = template.render(scope, locals, &block) ensure @default_layout = layout_was end # render layout if layout options = options.merge(:views == views, :layout == false, :eat_errors == eat_errors, :scope == scope) catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } } end output.extend(ContentTyped).content_type = content_type if content_type output end def compile_template(engine, data, options, views) eat_errors = options.delete :eat_errors template_cache.fetch eng
gine, data, options do template = Tilt[engine] raise "Template engine not found: #{engine}" if template.nil? case data when Symbol body, path, line = settings.templates[data] if body body = body.call if body.respond_to?(:call) template.new(path, line.to_i, options) { body } else found = false @preferred_extension = engine.to_s find_template(views, data, template) do |file| path ||= file # keep the initial path rather than the last one if found = File.exists?(file) path = file break end end throw :layout_missing if eat_errors and not found template.new(pat
th, 1, options) end when Proc, String body = data.is_a?(String) ? Proc.new { data } : data path, line = settings.caller_locations.first template.new(path, line.to_i, options, &body) else raise ArgumentError, "Sorry, don't know how to render #{data.inspect}." end end end end # Base class for all Sinatra applications and middleware. class Base include Rack::Utils include Helpers include Templates attr_accessor :app attr_reader :template_cache def initialize(app=nil) super() @app = app @template_cache = Tilt::Cache.new yield self if block_given? end # Rack c
call interface. def call(env) dup.call!(env) end attr_accessor :env, :request, :response, :params def call!(env) # :nodoc: @env = env @request = Request.new(env) @response = Response.new @params = indifferent_params(@request.params) template_cache.clear if settings.reload_templates force_encoding(@params) @response['Content–Type'] = nil invoke { dispatch! } invoke { error_block!(response.status) } unless @response['Content–Type'] if Array === body and body[0].respond_to? :content_type content_type body[0].content_type else content_type :html end end @resp
ponse.finish end # Access settings defined with Base.set. def self.settings self end # Access settings defined with Base.set. def settings self.class.settings end def options warn "Sinatra::Base#options is deprecated and will be removed, " \ "use #settings instead." settings end # Exit the current block, halts any further processing # of the request, and returns the specified response. def halt(*response) response = response.first if response.length == 1 throw :halt, response end # Pass control to the next matching route. # If there are no more matching r
routes, Sinatra will # return a 404 response. def pass(&block) throw :pass, block end # Forward the request to the downstream app –– middleware only. def forward fail "downstream app not set" unless @app.respond_to? :call status, headers, body = @app.call env @response.status = status @response.body = body @response.headers.merge! headers nil end private # Run filters defined on the class and all superclasses. def filter!(type, base = settings) filter! type, base.superclass if base.superclass.respond_to?(:filters) base.filters[type].each { |args| process_
_route(*args) } end # Run routes defined on the class and all superclasses. def route!(base = settings, pass_block=nil) if routes = base.routes[@request.request_method] routes.each do |pattern, keys, conditions, block| pass_block = process_route(pattern, keys, conditions) do |*args| route_eval { block[*args] } end end end # Run routes defined in superclass. if base.superclass.respond_to?(:routes) return route!(base.superclass, pass_block) end route_eval(&pass_block) if pass_block route_missing end # Run a route block and throw :halt with the result. def r
route_eval throw :halt, yield end # If the current request matches pattern and conditions, fill params # with keys and call the given block. # Revert params afterwards. # # Returns pass block. def process_route(pattern, keys, conditions, block = nil, values = []) route = @request.path_info route = '/' if route.empty? and not settings.empty_path_info? return unless match = pattern.match(route) values += match.captures.to_a.map { |v| force_encoding URI.decode_www_form_component(v) if v } if values.any? original, @params = params, params.merge('splat' == [],
, 'captures' == values) keys.zip(values) { |k,v| Array === @params[k] ? @params[k] << v : @params[k] = v if v } end catch(:pass) do conditions.each { |c| throw :pass if c.bind(self).call == false } block ? block[self, values] : yield(self, values) end ensure @params = original if original end # No matching route was found or all routes passed. The default # implementation is to forward the request downstream when running # as middleware (@app is non–nil); when no downstream app is set, raise # a NotFound exception. Subclasses can override this method to p
perform # custom route miss logic. def route_missing if @app forward else raise NotFound end end # Attempt to serve static files from public directory. Throws :halt when # a matching file is found, returns nil otherwise. def static! return if (public_dir = settings.public_folder).nil? public_dir = File.expand_path(public_dir) path = File.expand_path(public_dir + unescape(request.path_info)) return unless path.start_with?(public_dir) and File.file?(path) env['sinatra.static_file'] = path cache_control(*settings.static_cache_control) if settings.static_cach
he_control? send_file path, :disposition == nil end # Enable string or symbol key access to the nested params hash. def indifferent_params(object) case object when Hash new_hash = indifferent_hash object.each { |key, value| new_hash[key] = indifferent_params(value) } new_hash when Array object.map { |item| indifferent_params(item) } else object end end # Creates a Hash with indifferent access. def indifferent_hash Hash.new {|hash,key| hash[key.to_s] if Symbol === key } end # Run the block with 'throw :halt' support and apply result to the response. def in
nvoke res = catch(:halt) { yield } res = [res] if Fixnum === res or String === res if Array === res and Fixnum === res.first res = res.dup status(res.shift) body(res.pop) headers(*res) elsif res.respond_to? :each body res end nil # avoid double setting the same response tuple twice end # Dispatch a request with error handling. def dispatch! invoke do static! if settings.static? && (request.get? || request.head?) filter! :before route! end rescue ::Exception == boom invoke { handle_exception!(boom) } ensure filter! :after unless env['sinatra.static_file']
 end # Error handling during requests. def handle_exception!(boom) @env['sinatra.error'] = boom if boom.respond_to? :http_status status(boom.http_status) elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599 status(boom.code) else status(500) end status(500) unless status.between? 400, 599 if server_error? dump_errors! boom if settings.dump_errors? raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler end if not_found? headers['X–Cascade'] = 'pass' body '<h1=Not Found</h1=' end res = error_blo
ock!(boom.class, boom) || error_block!(status, boom) return res if res or not server_error? raise boom if settings.raise_errors? or settings.show_exceptions? error_block! Exception, boom end # Find an custom error block for the key(s) specified. def error_block!(key, *block_params) base = settings while base.respond_to?(:errors) next base = base.superclass unless args_array = base.errors[key] args_array.reverse_each do |args| first = args == args_array.first args += [block_params] resp = process_route(*args) return resp unless resp.nil? && !first end end
 return false unless key.respond_to? :superclass and key.superclass < Exception error_block!(key.superclass, *block_params) end def dump_errors!(boom) msg = ["#{boom.class} – #{boom.message}:", *boom.backtrace].join("\n\t") @env['rack.errors'].puts(msg) end class    self attr_reader :routes, :filters, :templates, :errors # Removes all routes, filters, middleware and extension hooks from the # current class (not routes/filters/... defined by its superclass). def reset! @conditions = [] @routes = {} @filters = {:before == [], :after == []} @errors = {} @mid
ddleware = [] @prototype = nil @extensions = [] if superclass.respond_to?(:templates) @templates = Hash.new { |hash,key| superclass.templates[key] } else @templates = {} end end # Extension modules registered on this class and all superclasses. def extensions if superclass.respond_to?(:extensions) (@extensions + superclass.extensions).uniq else @extensions end end # Middleware used in this class and all superclasses. def middleware if superclass.respond_to?(:middleware) superclass.middleware + @middleware else @middleware end end # Sets an option to the g
given value. If the value is a proc, # the proc will be called every time the option is accessed. def set(option, value = (not_set = true), ignore_setter = false, &block) raise ArgumentError if block and !not_set value, not_set = block, false if block if not_set raise ArgumentError unless option.respond_to?(:each) option.each { |k,v| set(k, v) } return self end if respond_to?("#{option}=") and not ignore_setter return __send__("#{option}=", value) end setter = proc { |val| set option, val, true } getter = proc { value } case value when Proc getter = value
e when Symbol, Fixnum, FalseClass, TrueClass, NilClass getter = value.inspect when Hash setter = proc do |val| val = value.merge val if Hash === val set option, val, true end end define_singleton_method("#{option}=", setter) if setter define_singleton_method(option, getter) if getter define_singleton_method("#{option}?", "!!#{option}") unless method_defined? "#{option}?" self end # Same as calling `set :option, true` for each of the given options. def enable(*opts) opts.each { |key| set(key, true) } end # Same as calling `set :option, false` for each of t
the given options. def disable(*opts) opts.each { |key| set(key, false) } end # Define a custom error handler. Optionally takes either an Exception # class, or an HTTP status code to specify which errors should be # handled. def error(*codes, &block) args = compile! "ERROR", //, block codes = codes.map { |c| Array(c) }.flatten codes << Exception if codes.empty? codes.each { |c| (@errors[c] ||= []) << args } end # Sugar for `error(404) { ... }` def not_found(&block) error 404, &block end # Define a named template. The block must return the template source.
. def template(name, &block) filename, line = caller_locations.first templates[name] = [block, filename, line.to_i] end # Define the layout template. The block must return the template source. def layout(name=:layout, &block) template name, &block end # Load embeded templates from the file; uses the caller's __FILE__ # when no file is specified. def inline_templates=(file=nil) file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file begin io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file) app, data = io.
.gsub("\r\n", "\n").split(/^__END__$/, 2) rescue Errno::ENOENT app, data = nil end if data if app and app =~ /([^\n]*\n)?#[^\n]*coding: *(\S+)/m encoding = $2 else encoding = settings.default_encoding end lines = app.count("\n") + 1 template = nil force_encoding data, encoding data.each_line do |line| lines += 1 if line =~ /^@@\s*(.*\S)\s*$/ template = force_encoding('', encoding) templates[$1.to_sym] = [template, file, lines] elsif template template << line end end end end # Lookup or register a mime type in Rack's mime registry. def mime_type(type, valu
ue=nil) return type if type.nil? || type.to_s.include?('/') type = ".#{type}" unless type.to_s[0] == ?. return Rack::Mime.mime_type(type, nil) unless value Rack::Mime::MIME_TYPES[type] = value end # provides all mime types matching type, including deprecated types: # mime_types :html # == ['text/html'] # mime_types :js # == ['application/javascript', 'text/javascript'] def mime_types(type) type = mime_type type type =~ /^application\/(xml|javascript)$/ ? [type, "text/#$1"] : [type] end # Define a before filter; runs before all requests within the same # c
context as route handlers and may access/modify the request and # response. def before(path = nil, options = {}, &block) add_filter(:before, path, options, &block) end # Define an after filter; runs after all requests within the same # context as route handlers and may access/modify the request and # response. def after(path = nil, options = {}, &block) add_filter(:after, path, options, &block) end # add a filter def add_filter(type, path = nil, options = {}, &block) path, options = //, path if path.respond_to?(:each_pair) filters[type] << compile!(type,
 path || //, block, options) end # Add a route condition. The route is considered non–matching when the # block returns false. def condition(name = "#{caller.first[/`.*'/]} condition", &block) @conditions    generate_method(name, &block) end def public=(value) warn ":public is no longer used to avoid overloading Module#public, use :public_dir instead" set(:public_folder, value) end def public_dir=(value) self.public_folder = value end def public_dir public_folder end private # Dynamically defines a method on settings. def define_singleton_method(name, con
ntent = Proc.new) # replace with call to singleton_class once we're 1.9 only (class << self; self; end).class_eval do undef_method(name) if method_defined? name String === content ? class_eval("def #{name}() #{content}; end") : define_method(name, &content) end end # Condition for matching host name. Parameter might be String or Regexp. def host_name(pattern) condition { pattern === request.host } end # Condition for matching user agent. Parameter should be Regexp. # Will set params[:agent]. def user_agent(pattern) condition do if request.user_agent.to_s
 =~ pattern @params[:agent] = $~[1..–1] true else false end end end alias_method :agent, :user_agent # Condition for matching mimetypes. Accepts file extensions. def provides(*types) types.map! { |t| mime_types(t) } types.flatten! condition do if type = response['Content–Type'] types.include? type or types.include? type[/^[^;]+/] elsif type = request.preferred_type(types) content_type(type) true else false end end end public # Defining a `GET` handler also automatically defines # a `HEAD` handler. def get(path, opts={}, &block) conditions = @conditions.du
up route('GET', path, opts, &block) @conditions = conditions route('HEAD', path, opts, &block) end def put(path, opts={}, &bk) route 'PUT', path, opts, &bk end def post(path, opts={}, &bk) route 'POST', path, opts, &bk end def delete(path, opts={}, &bk) route 'DELETE', path, opts, &bk end def head(path, opts={}, &bk) route 'HEAD', path, opts, &bk end def options(path, opts={}, &bk) route 'OPTIONS', path, opts, &bk end def patch(path, opts={}, &bk) route 'PATCH', path, opts, &bk end private def route(verb, path, options={}, &block) # Because of self.option
ns.host host_name(options.delete(:host)) if options.key?(:host) enable :empty_path_info if path == "" and empty_path_info.nil? signature = compile!(verb, path, block, options) (@routes[verb] ||= [])    signature invoke_hook(:route_added, verb, path, block) signature end def invoke_hook(name, *args) extensions.each { |e| e.send(name, *args) if e.respond_to?(name) } end def generate_method(method_name, &block) define_method(method_name, &block) method = instance_method method_name remove_method method_name method end def compile!(verb, path, block, options
 = {}) options.each_pair { |option, args| send(option, *args) } method_name = "#{verb} #{path}" unbound_method = generate_method(method_name, &block) pattern, keys = compile path conditions, @conditions = @conditions, [] [ pattern, keys, conditions, block.arity != 0 ? proc { |a,p| unbound_method.bind(a).call(*p) } : proc { |a,p| unbound_method.bind(a).call } ] end def compile(path) keys = [] if path.respond_to? :to_str ignore = "" pattern = path.to_str.gsub(/[^\?\%\\\/\:\*\w]/) do |c| ignore << escaped(c).join if c.match(/[\.@]/) patt = encoded(c) patt.gs
sub(/%[\da–fA–F]{2}/) do |match| match.split(//).map {|char| char =~ /[A–Z]/ ? "[#{char}#{char.tr('A–Z', 'a–z')}]" : char}.join end end pattern.gsub!(/((:\w+)|\*)/) do |match| if match == "*" keys    'splat' "(.*?)" else keys    $2[1..–1] ignore_pattern = safe_ignore(ignore) ignore_pattern end end [/\A#{pattern}\z/, keys] elsif path.respond_to?(:keys) && path.respond_to?(:match) [path, path.keys] elsif path.respond_to?(:names) && path.respond_to?(:match) [path, path.names] elsif path.respond_to? :match [path, keys] else raise TypeError, path end end URI =
= ::URI.const_defined?(:Parser) ? ::URI::Parser.new : ::URI def encoded(char) enc = URI.escape(char) enc = "(?:#{escaped(char, enc).join('|')})" if enc == char enc = "(?:#{enc}|#{encoded('+')})" if char == " " enc end def escaped(char, enc = URI.escape(char)) [Regexp.escape(enc), URI.escape(char, /./)] end def safe_ignore(ignore) unsafe_ignore = [] ignore = ignore.gsub(/%[\da–fA–F]{2}/) do |hex| unsafe_ignore << hex[1..2] '' end unsafe_patterns = unsafe_ignore.map do |unsafe| chars = unsafe.split(//).map do |char| if char =~ /[A–Z]/ char <<= char.tr('A–Z'
', 'a–z') end char end "|(?:%[^#{chars[0]}].|%[#{chars[0]}][^#{chars[1]}])" end if unsafe_patterns.length = 0 "((?:[^#{ignore}/?#%]#{unsafe_patterns.join()})+)" else "([^#{ignore}/?#]+)" end end public # Makes the methods defined in the block and in the Modules given # in `extensions` available to the handlers and templates def helpers(*extensions, &block) class_eval(&block) if block_given? include(*extensions) if extensions.any? end # Register an extension. Alternatively take a block from which an # extension will be created and registered on the fly. de
ef register(*extensions, &block) extensions << Module.new(&block) if block_given? @extensions += extensions extensions.each do |extension| extend extension extension.registered(self) if extension.respond_to?(:registered) end end def development?; environment == :development end def production?; environment == :production end def test?; environment == :test end # Set configuration options for Sinatra and/or the app. # Allows scoping of settings for certain environments. def configure(*envs, &block) yield self if envs.empty? || envs.include?(environment.to_
_sym) end # Use the specified Rack middleware def use(middleware, *args, &block) @prototype = nil @middleware << [middleware, args, block] end def quit!(server, handler_name) # Use Thin's hard #stop! if available, otherwise just #stop. server.respond_to?(:stop!) ? server.stop! : server.stop $stderr.puts "\n== Sinatra has ended his set (crowd applauds)" unless handler_name =~/cgi/i end # Run the Sinatra app as a self–hosted server using # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call # with the constructed handler once we hav
ve taken the stage. def run!(options={}) set options handler = detect_rack_handler handler_name = handler.name.gsub(/.*::/, '') server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {} handler.run self, server_settings.merge(:Port == port, :Host == bind) do |server| unless handler_name =~ /cgi/i $stderr.puts "== Sinatra/#{Sinatra::VERSION} has taken the stage " + "on #{port} for #{environment} with backup from #{handler_name}" end [:INT, :TERM].each { |sig| trap(sig) { quit!(server, handler_name) } } server.threaded = setti
ings.threaded if server.respond_to? :threaded= set :running, true yield server if block_given? end rescue Errno::EADDRINUSE $stderr.puts "== Someone is already performing on port #{port}!" end # The prototype instance used to process requests. def prototype @prototype ||= new end # Create a new instance without middleware in front of it. alias new! new unless method_defined? :new! # Create a new instance of the class fronted by its middleware # pipeline. The object is guaranteed to respond to #call but may not be # an instance of the class new was called
 on. def new(*args, &bk) instance = new!(*args, &bk) Wrapper.new(build(instance).to_app, instance) end # Creates a Rack::Builder instance with all the middleware set up and # the given +app+ as end point. def build(app) builder = Rack::Builder.new setup_default_middleware builder setup_middleware builder builder.run app builder end def call(env) synchronize { prototype.call(env) } end private def setup_default_middleware(builder) builder.use ExtendedRack builder.use ShowExceptions if show_exceptions? builder.use Rack::MethodOverride if method_override? bu
uilder.use Rack::Head setup_logging builder setup_sessions builder setup_protection builder end def setup_middleware(builder) middleware.each { |c,a,b| builder.use(c, *a, &b) } end def setup_logging(builder) if logging? setup_common_logger(builder) setup_custom_logger(builder) elsif logging == false setup_null_logger(builder) end end def setup_null_logger(builder) builder.use Rack::NullLogger end def setup_common_logger(builder) builder.use Sinatra::CommonLogger end def setup_custom_logger(builder) if logging.respond_to? :to_int builder.use Rack::Logger,
logging else builder.use Rack::Logger end end def setup_protection(builder) return unless protection? options = Hash === protection ? protection.dup : {} options[:except] = Array options[:except] options[:except] += [:session_hijacking, :remote_token] unless sessions? options[:reaction] ||= :drop_session builder.use Rack::Protection, options end def setup_sessions(builder) return unless sessions? options = {} options[:secret] = session_secret if session_secret? options.merge! sessions.to_hash if sessions.respond_to? :to_hash builder.use Rack::Session::Co ookie, options end def detect_rack_handler servers = Array(server) servers.each do |server_name| begin return Rack::Handler.get(server_name.to_s) rescue LoadError, NameError end end fail "Server handler (#{servers.join(',')}) not found." end def inherited(subclass) subclass.reset! subclass.set :app_file, caller_files.first unless subclass.app_file? super end @@mutex = Mutex.new def synchronize(&block) if lock? @@mutex.synchronize(&block) else yield end end public CALLERS_TO_IGNORE = [ # :nodoc: /\/sinatra(\/(base|main|showexceptions))?\.rb$/, # all sinatr ra code /lib\/tilt.*\.rb$/, # all tilt code /^\(.*\)$/, # generated code /rubygems\/custom_require\.rb$/, # rubygems require hacks /active_support/, # active_support require hacks /bundler(\/runtime)?\.rb/, # bundler require hacks / internal:/, # internal in ruby == 1.9.2 /src\/kernel\/bootstrap\/[A–Z]/ # maglev kernel files ] # contrary to what the comment said previously, rubinius never supported this if defined?(RUBY_IGNORE_CALLERS) warn "RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0" CALLERS_TO_IGNORE.concat(RUBY_IGN NORE_CALLERS) end # Like Kernel#caller but excluding certain magic entries and without # line / method information; the resulting array contains filenames only. def caller_files cleaned_caller(1).flatten end # Like caller_files, but containing Arrays rather than strings with the # first element being the file, and the second being the line. def caller_locations cleaned_caller 2 end private # used for deprecation warnings def warn(message) super message + "\n\tfrom #{cleaned_caller.first.join(':')}" end # Like Kernel#caller but excluding certain magic entr ries def cleaned_caller(keep = 3) caller(1). map { |line| line.split(/:(?=\d|in )/, 3)[0,keep] }. reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } } end end # Fixes encoding issues by # * defaulting to UTF–8 # * casting params to Encoding.default_external # # The latter might not be necessary if Rack handles it one day. # Keep an eye on Rack's LH #100. def force_encoding(*args) settings.force_encoding(*args) end if defined? Encoding def self.force_encoding(data, encoding = default_encoding) return if data == settings || data.is_a?( (Tempfile) if data.respond_to? :force_encoding data.force_encoding(encoding).encode! elsif data.respond_to? :each_value data.each_value { |v| force_encoding(v, encoding) } elsif data.respond_to? :each data.each { |v| force_encoding(v, encoding) } end data end else def self.force_encoding(data, *) data end end reset! set :environment, (ENV['RACK_ENV'] || :development).to_sym set :raise_errors, Proc.new { test? } set :dump_errors, Proc.new { !test? } set :show_exceptions, Proc.new { development? } set :sessions, false set :logging, false set :protection, tr rue set :method_override, false set :use_code, false set :default_encoding, "utf–8" set :add_charset, %w[javascript xml xhtml+xml json].map { |t| "application/#{t}" } settings.add_charset /^text\// # explicitly generating a session secret eagerly to play nice with preforking begin require 'securerandom' set :session_secret, SecureRandom.hex(64) rescue LoadError, NotImplementedError # SecureRandom raises a NotImplementedError if no random device is available set :session_secret, "%064x" % Kernel.rand(2**256–1) end class << self alias_method :methodoverr ride?, :method_override? alias_method :methodoverride=, :method_override= end set :run, false # start server via at–exit hook? set :running, false # is the built–in server running now? set :server, %w[http webrick] set :bind, '0.0.0.0' set :port, Integer(ENV['PORT'] || 4567) ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE if ruby_engine == 'macruby' server.unshift 'control_tower' else server.unshift 'mongrel' if ruby_engine.nil? server.unshift 'puma' if ruby_engine != 'rbx' server.unshift 'thin' if ruby_engine != 'jruby' server.unshift 'puma' if ruby_e engine == 'rbx' server.unshift 'trinidad' if ruby_engine =='jruby' end set :absolute_redirects, true set :prefixed_redirects, false set :empty_path_info, nil set :app_file, nil set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) } set :views, Proc.new { root && File.join(root, 'views') } set :reload_templates, Proc.new { development? } set :lock, false set :threaded, true set :public_folder, Proc.new { root && File.join(root, 'public') } set :static, Proc.new { public_folder && File.exist?(public_folder) } set :static_cache_control, , false error ::Exception do response.status = 500 content_type 'text/html' '<h1=Internal Server Error</h1=' end configure :development do get '/__sinatra__/:image.png' do filename = File.dirname(__FILE__) + "/images/#{params[:image]}.png" content_type :png send_file filename end error NotFound do content_type 'text/html' if self.class == Sinatra::Application code = <<–RUBY.gsub(/^ {12}/, '') #{request.request_method.downcase} '#{request.path_info}' do "Hello World" end RUBY else code = <<–RUBY.gsub(/^ {12}/, '') class #{self.class} #{request.request_meth hod.downcase} '#{request.path_info}' do "Hello World" end end RUBY file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\//, '') code = "# in #{file}\n#{code}" unless file.empty? end ( –HTML).gsub(/^ {10}/, '') !DOCTYPE html= html= head= style type="text/css"= body { text–align:center;font–family:helvetica,arial;font–size:22px; color:#888;margin:20px} #c {margin:0 auto;width:500px;text–align:left} </style= </head= <body= <h2=Sinatra doesn&rsquo;t know this ditty.</h2= <img src='#{uri "/__sinatra__/404.png"}'= <div id="c"= Try this: <pre=#{ {code}</pre= </div= </body= </html= HTML end end end # Execution context for classic style (top–level) applications. All # DSL methods executed on main are delegated to this class. # # The Application class should not be subclassed, unless you want to # inherit all settings, routes, handlers, and error pages from the # top–level. Subclassing Sinatra::Base is highly recommended for # modular applications. class Application < Base set :logging, Proc.new { ! test? } set :method_override, true set :run, Proc.new { ! test? } set :session_secret, Proc.new { sup per() unless development? } set :app_file, nil def self.register(*extensions, &block) #:nodoc: added_methods = extensions.map {|m| m.public_instance_methods }.flatten Delegator.delegate(*added_methods) super(*extensions, &block) end end # Sinatra delegation mixin. Mixing this module into an object causes all # methods to be delegated to the Sinatra::Application class. Used primarily # at the top–level. module Delegator #:nodoc: def self.delegate(*methods) methods.each do |method_name| define_method(method_name) do |*args, &block| return super(*args, &bloc ck) if respond_to? method_name Delegator.target.send(method_name, *args, &block) end private method_name end end delegate :get, :patch, :put, :post, :delete, :head, :options, :template, :layout, :before, :after, :error, :not_found, :configure, :set, :mime_type, :enable, :disable, :use, :development?, :test?, :production?, :helpers, :settings, :register class << self attr_accessor :target end self.target = Application end class Wrapper def initialize(stack, instance) @stack, @instance = stack, instance end def settings @instance.settings end def helpers @i instance end def call(env) @stack.call(env) end def inspect "#<#{@instance.class} app_file=#{settings.app_file.inspect}=" end end # Create a new Sinatra application. The block is evaluated in the new app's # class scope. def self.new(base=Base, options={}, &block) base = Class.new(base) base.class_eval(&block) if block_given? base end # Extend the top–level DSL with the modules provided. def self.register(*extensions, &block) Delegator.target.register(*extensions, &block) end # Include the helper modules provided in Sinatra's request context. def self.hel lpers(*extensions,&block)Delegator.target.helpers(*extensions,&block)end#Usethemiddlewareforclassicapplications.defself.use(*args,&block)Delegator.target.use(*args,&block)endendrequire'sinatra/base'moduleSinatraclassApplication Base#weassumethatthefirstfilethatrequires'sinatra'isthe#app_file.allotherpathrelatedoptionsarecalculatedbased#onthispathbydefault.set:app_file,caller_files.first||$0set:run,Proc.new{File.expand_path($0)==File.expand_path(app_file)}ifrun?&&ARGV.any?require'optp parse' OptionParser.new { |op| op.on('–p port', 'set the port (default is 4567)') { |val| set :port, Integer(val) } op.on('–o addr', 'set the host (default is 0.0.0.0)') { |val| set :bind, val } op.on('–e env', 'set the environment (default is development)') { |val| set :environment, val.to_sym } op.on('–s server', 'specify rack server/handler (default is thin)') { |val| set :server, val } op.on('–x', 'turn on the mutex lock (default is off)') { set :lock, true } }.parse!(ARGV.dup) end end at_exit { Application.run! if $!.nil? && Application.run? } end #
 include would include the module in Object # extend only extends the `main` object extend Sinatra::Delegator require 'rack/showexceptions' module Sinatra # Sinatra::ShowExceptions catches all exceptions raised from the app it # wraps. It shows a useful backtrace with the sourcefile and clickable # context, the whole Rack environment and the request data. # # Be careful when you use this on public–facing sites as it could reveal # information helpful to attackers. class ShowExceptions < Rack::ShowExceptions @@eats_errors = Object.new def @@eats_errors.flu
ush(*) end def @@eats_errors.puts(*) end def initialize(app) @app = app @template = ERB.new(TEMPLATE) end def call(env) @app.call(env) rescue Exception == e errors, env["rack.errors"] = env["rack.errors"], @@eats_errors if prefers_plain_text?(env) content_type = "text/plain" body = [dump_exception(e)] else content_type = "text/html" body = pretty(env, e) end env["rack.errors"] = errors [500, {"Content–Type" == content_type, "Content–Length" == Rack::Utils.bytesize(body.join).to_s}, body] end private def prefers_plain_text?(env) !(Request.new(env).preferre
ed_type("text/plain","text/html") == "text/html") && [/curl/].index{|item| item =~ env["HTTP_USER_AGENT"]} end def frame_class(frame) if frame.filename =~ /lib\/sinatra.*\.rb/ "framework" elsif (defined?(Gem) && frame.filename.include?(Gem.dir)) || frame.filename =~ /\/bin\/(\w+)$/ "system" else "app" end end TEMPLATE = <<–HTML # :nodoc: <!DOCTYPE html= <html= <head= <meta http–equiv="Content–Type" content="text/html; charset=utf–8"/= <title=<%=h exception.class %= at <%=h path %=</title= <script type="text/javascript"= //<!–– function toggle(id) { var pr
re = document.getElementById("pre–" + id); var post = document.getElementById("post–" + id); var context = document.getElementById("context–" + id); if (pre.style.display == 'block') { pre.style.display = 'none'; post.style.display = 'none'; context.style.background = "none"; } else { pre.style.display = 'block'; post.style.display = 'block'; context.style.background = "#fffed9"; } } function toggleBacktrace(){ var bt = document.getElementById("backtrace"); var toggler = document.getElementById("expando"); if (bt.className == 'condensed') { bt.className =
= 'expanded'; toggler.innerHTML = "(condense)"; } else { bt.className = 'condensed'; toggler.innerHTML = "(expand)"; } } //––= </script= <style type="text/css" media="screen"= * {margin: 0; padding: 0; border: 0; outline: 0;} div.clear {clear: both;} body {background: #EEEEEE; margin: 0; padding: 0; font–family: 'Lucida Grande', 'Lucida Sans Unicode', 'Garuda';} code {font–family: 'Lucida Console', monospace; font–size: 12px;} li {height: 18px;} ul {list–style: none; margin: 0; padding: 0;} ol:hover {cursor: pointer;} ol li {white–space: pre;} #explanatio
on {font–size: 12px; color: #666666; margin: 20px 0 0 100px;} /* WRAP */ #wrap {width: 1000px; background: #FFFFFF; margin: 0 auto; padding: 30px 50px 20px 50px; border–left: 1px solid #DDDDDD; border–right: 1px solid #DDDDDD;} /* HEADER */ #header {margin: 0 auto 25px auto;} #header img {float: left;} #header #summary {float: left; margin: 12px 0 0 20px; width:660px; font–family: 'Lucida Grande', 'Lucida Sans Unicode';} h1 {margin: 0; font–size: 36px; color: #981919;} h2 {margin: 0; font–size: 22px; color: #333333;} #header ul {margin: 0; font–size: 12px
x; color: #666666;} #header ul li strong{color: #444444;} #header ul li {display: inline; padding: 0 10px;} #header ul li.first {padding–left: 0;} #header ul li.last {border: 0; padding–right: 0;} /* BODY */ #backtrace, #get, #post, #cookies, #rack {width: 980px; margin: 0 auto 10px auto;} p#nav {float: right; font–size: 14px;} /* BACKTRACE */ a#expando {float: left; padding–left: 5px; color: #666666; font–size: 14px; text–decoration: none; cursor: pointer;} a#expando:hover {text–decoration: underline;} h3 {float: left; width: 100px; margin–bottom: 10px;
color: #981919; font–size: 14px; font–weight: bold;} #nav a {color: #666666; text–decoration: none; padding: 0 5px;} #backtrace li.frame–info {background: #f7f7f7; padding–left: 10px; font–size: 12px; color: #333333;} #backtrace ul {list–style–position: outside; border: 1px solid #E9E9E9; border–bottom: 0;} #backtrace ol {width: 920px; margin–left: 50px; font: 10px 'Lucida Console', monospace; color: #666666;} #backtrace ol li {border: 0; border–left: 1px solid #E9E9E9; padding: 2px 0;} #backtrace ol code {font–size: 10px; color: #555555; padding–left: 5 5px;} #backtrace–ul li {border–bottom: 1px solid #E9E9E9; height: auto; padding: 3px 0;} #backtrace–ul .code {padding: 6px 0 4px 0;} #backtrace.condensed .system, #backtrace.condensed .framework {display:none;} /* REQUEST DATA */ p.no–data {padding–top: 2px; font–size: 12px; color: #666666;} table.req {width: 980px; text–align: left; font–size: 12px; color: #666666; padding: 0; border–spacing: 0; border: 1px solid #EEEEEE; border–bottom: 0; border–left: 0; clear:both} table.req tr th {padding: 2px 10px; font–weight: bold; background: #F7F7F7; border–botto om: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} table.req tr td {padding: 2px 20px 2px 10px; border–bottom: 1px solid #EEEEEE; border–left: 1px solid #EEEEEE;} /* HIDE PRE/POST CODE AT START */ .pre–context, .post–context {display: none;} table td.code {width:750px} table td.code div {width:750px;overflow:hidden} </style= </head= <body= <div id="wrap"= <div id="header"= <img src="<%= env['SCRIPT_NAME'] %=/__sinatra__/500.png" alt="application error" height="161" width="313" /= <div id="summary"= <h1=<strong=<%=h exception.class %=</strong= at <str rong=<%=h path %= </strong=</h1= <h2=<%=h exception.message %=</h2= <ul= <li class="first"=<strong=file:</strong= <code= <%=h frames.first.filename.split("/").last %=</code=</li= <li=<strong=location: /strong= code= %=h frames.first.function %= /code= /li= li class="last"= strong=line: /strong= %=h frames.first.lineno %=</li= </ul= </div= <div class="clear"=</div= </div= <div id="backtrace" class='condensed'= <h3=BACKTRACE</h3= <p=<a href="#" id="expando" onclick="toggleBacktrace(); return false"=(expand)</a=</p= <p id="nav"=<strong=JUMP TO:</strong= = <a href="#get–info"=GET</a= <a href="#post–info"=POST</a= <a href="#cookie–info"=COOKIES</a= <a href="#env–info"=ENV</a= </p= <div class="clear"=</div= <ul id="backtrace–ul"= <% id = 1 %= % frames.each do |frame| %= % if frame.context_line && frame.context_line != "#" %= li class="frame–info %= frame_class(frame) %="= <code=<%=h frame.filename %=</code= in <code=<strong=<%=h frame.function %=</strong=</code= </li= <li class="code <%= frame_class(frame) %="= <% if frame.pre_context %= <ol start="<%=h frame.pre_context_lineno + 1 %=" class="pre–contex xt" id="pre–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.pre_context.each do |line| %= <li class="pre–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <ol start=" %= frame.lineno %=" class="context" id=" %= id %=" onclick="toggle( %= id %=);"= li class="context–line" id="context– %= id %="=<code=<%= h frame.context_line %=</code=</li= </ol= <% if frame.post_context %= <ol start="<%=h frame.lineno + 1 %=" class="post–context" id="post–<%= id %=" onclick="toggle(<%= id %=);"= <% frame.post_context.each do |line| %= <li class="pos st–context–line"=<code=<%=h line %=</code=</li= <% end %= </ol= <% end %= <div class="clear"=</div= </li= <% end %= <% id += 1 %= <% end %= </ul= </div= <!–– /BACKTRACE ––= <div id="get"= h3 id="get–info"=GET /h3= % if req.GET and not req.GET.empty? %= table class="req"= tr= th=Variable /th= th=Value /th= /tr= <% req.GET.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No GET data.</p= <% end %= <div class="clear"=</div= = </div= <!–– /GET ––= <div id="post"= <h3 id="post–info"=POST</h3= <% if req.POST and not req.POST.empty? %= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% req.POST.sort_by { |k, v| k.to_s }.each { |key, val| %= tr= td= %=h key %= /td= td class="code"= div= %=h val.inspect %= /div= /td= /tr= <% } %= </table= <% else %= <p class="no–data"=No POST data.</p= <% end %= <div class="clear"=</div= </div= <!–– /POST ––= <div id="cookies"= <h3 id="cookie–info"=COOKIES</h3= <% unless req.cookies.empty? %= <table class="req"= <tr= <th=Variab ble</th= <th=Value</th= </tr= <% req.cookies.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val.inspect %=</div=</td= </tr= <% } %= </table= <% else %= <p class="no–data"=No cookie data. /p= % end %= div class="clear"= /div= /div= !–– /COOKIES ––= div id="rack"= h3 id="env–info"=Rack ENV</h3= <table class="req"= <tr= <th=Variable</th= <th=Value</th= </tr= <% env.sort_by { |k, v| k.to_s }.each { |key, val| %= <tr= <td=<%=h key %=</td= <td class="code"=<div=<%=h val %=</div=</td= </tr= <% } %= </table= <div class="clear"=</d div= </div= <!–– /RACK ENV ––= <p id="explanation"=You're seeing this error because you have enabled the <code=show_exceptions</code= setting.</p= </div= <!–– /WRAP ––= </body= </html= HTML end end module Sinatra VERSION = '1.4.0' end $LOAD_PATH.unshift File.expand_path('../lib', __FILE__) require 'sinatra/version' Gem::Specification.new 'sinatra', Sinatra::VERSION do |s| s.description = "Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort." s.summary = "Classy web–development dressed in a DSL" s.authors = ["Blake Mizerany", , "Ryan Tomayko", "Simon Rozet", "Konstantin Haase"] s.email = "sinatrarb@googlegroups.com" s.homepage = "http://www.sinatrarb.com/" s.files = `git ls–files`.split("\n") – %w[.gitignore .travis.yml] s.test_files = s.files.select { |p| p =~ /^test\/.*_test.rb/ } s.extra_rdoc_files = s.files.select { |p| p =~ /^README/ } << 'LICENSE' s.rdoc_options = %w[––line–numbers ––inline–source ––title Sinatra ––main README.rdoc ––encoding=UTF–8] s.add_dependency 'rack', '~= 1.4' s.add_dependency 'rack–protection', '~= 1.3' s.add_dependency 'tilt', '~= 1.3', '== 1.3.3 3' end require File.expand_path('../helper', __FILE__) class BaseTest < Test::Unit::TestCase def test_default assert true end describe 'Sinatra::Base subclasses' do class TestApp < Sinatra::Base get('/') { 'Hello World' } end it 'include Rack::Utils' do assert TestApp.included_modules.include?(Rack::Utils) end it 'processes requests with #call' do assert TestApp.respond_to?(:call) request = Rack::MockRequest.new(TestApp) response = request.get('/') assert response.ok? assert_equal 'Hello World', response.body end class TestApp < Sinatra::Base get '/state' ' do @foo ||= "new" body = "Foo: #{@foo}" @foo = 'discard' body end end it 'does not maintain state between requests' do request = Rack::MockRequest.new(TestApp) 2.times do response = request.get('/state') assert response.ok? assert_equal 'Foo: new', response.body end end it "passes the subclass to configure blocks" do ref = nil TestApp.configure { |app| ref = app } assert_equal TestApp, ref end it "allows the configure block arg to be omitted and does not change context" do context = nil TestApp.configure { context = self } assert_equal self, context end d end describe "Sinatra::Base#new" do it 'returns a wrapper' do assert_equal Sinatra::Wrapper, Sinatra::Base.new.class end it 'implements a nice inspect' do assert_equal '#<Sinatra::Base app_file=nil=', Sinatra::Base.new.inspect end it 'exposes settings' do assert_equal Sinatra::Base.settings, Sinatra::Base.new.settings end it 'expses helpers' do assert_equal 'image/jpeg', Sinatra::Base.new.helpers.mime_type(:jpg) end end describe "Sinatra::Base as Rack middleware" do app = lambda { |env| headers = {'X–Downstream' == 'true'} headers['X–Route–Missing'] = e env['sinatra.route–missing'] || '' [210, headers, ['Hello from downstream']] } class TestMiddleware < Sinatra::Base end it 'creates a middleware that responds to #call with .new' do middleware = TestMiddleware.new(app) assert middleware.respond_to?(:call) end it 'exposes the downstream app' do middleware = TestMiddleware.new!(app) assert_same app, middleware.app end class TestMiddleware < Sinatra::Base def route_missing env['sinatra.route–missing'] = '1' super end get('/') { 'Hello from middleware' } end middleware = TestMiddleware.new(app) request = Rack k::MockRequest.new(middleware) it 'intercepts requests' do response = request.get('/') assert response.ok? assert_equal 'Hello from middleware', response.body end it 'automatically forwards requests downstream when no matching route found' do response = request.get('/missing') assert_equal 210, response.status assert_equal 'Hello from downstream', response.body end it 'calls #route_missing before forwarding downstream' do response = request.get('/missing') assert_equal '1', response['X–Route–Missing'] end class TestMiddleware < Sinatra::Base get('/low–lev vel–forward'){app.call(env)}endit'cancallthedownstreamappdirectlyandreturnresult'doresponse=request.get('/low–level–forward')assert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal'Hellofromdownstream',response.bodyendclassTestMiddleware Sinatra::Baseget'/explicit–forward'doresponse['X–Middleware']='true'res=forwardassert_nilresassert_equal210,response.statusassert_equal'true',response['X–Downstream']assert_equal['Hellofromdownstream'],response.body'Helloafterexplici it forward' end end it 'forwards the request downstream and integrates the response into the current context' do response = request.get('/explicit–forward') assert_equal 210, response.status assert_equal 'true', response['X–Downstream'] assert_equal 'Hello after explicit forward', response.body assert_equal '28', response['Content–Length'] end app_content_length = lambda {|env| [200, {'Content–Length' == '16'}, 'From downstream!']} class TestMiddlewareContentLength < Sinatra::Base get '/forward' do res = forward 'From after explicit forward!' end end midd dleware_content_length = TestMiddlewareContentLength.new(app_content_length) request_content_length = Rack::MockRequest.new(middleware_content_length) it "sets content length for last response" do response = request_content_length.get('/forward') assert_equal '28', response['Content–Length'] end end end require File.expand_path('../helper', __FILE__) begin require 'builder' class BuilderTest < Test::Unit::TestCase def builder_app(options = {}, &block) mock_app do set :views, File.dirname(__FILE__) + '/views' set options get('/', &block) end get '/' end it t 'renders inline Builder strings' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal %{<?xml version="1.0" encoding="UTF–8"?=\n}, body end it 'defaults content type to xml' do builder_app { builder 'xml.instruct!' } assert ok? assert_equal "application/xml;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do builder_app do content_type :html builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type glob bally' do builder_app(:builder == { :content_type == 'html' }) do builder 'xml.instruct!' end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'renders inline blocks' do builder_app do @name = "Frank & Mary" builder { |xml| xml.couple @name } end assert ok? assert_equal " couple=Frank &amp; Mary</couple=\n", body end it 'renders .builder files in views path' do builder_app do @name = "Blue" builder :hello end assert ok? assert_equal %(<exclaim=You're my boy, Blue!</exclaim=\n), body end it "renders with inline layouts" do o mock_app do layout { %(xml.layout { xml << yield }) } get('/') { builder %(xml.em 'Hello World') } end get '/' assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "renders with file layouts" do builder_app do builder %(xml.em 'Hello World'), :layout == :layout2 end assert ok? assert_equal "<layout=\n<em=Hello World</em=\n</layout=\n", body end it "raises error if template not found" do mock_app do get('/') { builder :no_such_template } end assert_raise(Errno::ENOENT) { get('/') } end end rescue LoadError warn "#{$!.to_s}:
skippingbuildertests"endrequireFile.expand_path('../helper',__FILE__)beginrequire'coffee–script'require'execjs'beginExecJS.compile'1'rescueExceptionraiseLoadError,'unabletoexecuteJavaScript'endclassCoffeeTest Test::Unit::TestCasedefcoffee_app(options={},&block)mock_appdoset:views,File.dirname(__FILE__)+'/views'set(options)get('/',&block)endget'/'endit'rendersinlineCoffeestrings'docoffee_app{coffee"alert'Aye!'\n"}assertok?assertbody.include?("alert('Aye!');")endit'defaultscontenttypetoja avascript' do coffee_app { coffee "alert 'Aye!'\n" } assert ok? assert_equal "application/javascript;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type per route' do coffee_app do content_type :html coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it 'defaults allows setting content type globally' do coffee_app(:coffee == { :content_type == 'html' }) do coffee "alert 'Aye!'\n" end assert ok? assert_equal "text/html;charset=utf–8", response['Content–Type'] end it
'renders .coffee files in views path' do coffee_app { coffee :hello } assert ok? assert_include body, "alert(\"Aye!\");" end it 'ignores the layout option' do coffee_app { coffee :hello, :layout == :layout2 } assert ok? assert_include body, "alert(\"Aye!\");" end it "raises error if template not found" do mock_app { get('/') { coffee :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes coffee options to the coffee engine" do coffee_app { coffee "alert 'Aye!'\n", :no_wrap == true } assert ok? assert_body "alert('Aye!');" end it "p passes default coffee options to the coffee engine" do mock_app do set :coffee, :no_wrap == true # default coffee style is :nested get('/') { coffee "alert 'Aye!'\n" } end get '/' assert ok? assert_body "alert('Aye!');" end end rescue LoadError warn "#{$!.to_s}: skipping coffee tests" end # I like coding: UTF–8 require File.expand_path('../helper', __FILE__) class CompileTest < Test::Unit::TestCase def self.converts pattern, expected_regexp it "generates #{expected_regexp.source} from #{pattern}" do compiled, _ = compiled pattern assert_equal expected_reg gexp, compiled end end def self.parses pattern, example, expected_params it "parses #{example} with #{pattern} into params #{expected_params}" do compiled, keys = compiled pattern match = compiled.match(example) fail %Q{"#{example}" does not parse on pattern "#{pattern}".} unless match # Aggregate e.g. multiple splat values into one array. # params = keys.zip(match.captures).reduce({}) do |hash, mapping| key, value = mapping hash[key] = if existing = hash[key] existing.respond_to?(:to_ary) ? existing << value : [existing, value] else value end hash end as ssert_equal(expected_params, params) end end def self.fails pattern, example it "does not parse #{example} with #{pattern}" do compiled, _ = compiled pattern match = compiled.match(example) fail %Q{"#{pattern}" does parse "#{example}" but it should fail} if match end end def compiled pattern app ||= mock_app {} compiled, keys = app.send(:compile, pattern) [compiled, keys] end converts "/", %r{\A/\z} parses "/", "/", {} converts "/foo", %r{\A/foo\z} parses "/foo", "/foo", {} converts "/:foo", %r{\A/([^/?#]+)\z} parses "/:foo", "/foo", "foo" == "foo" parses s "/:foo", "/foo.bar", "foo" == "foo.bar" parses "/:foo", "/foo%2Fbar", "foo" == "foo%2Fbar" parses "/:foo", "/%0Afoo", "foo" == "%0Afoo" fails "/:foo", "/foo?" fails "/:foo", "/foo/bar" fails "/:foo", "/" fails "/:foo", "/foo/" converts "/föö", %r{\A/f%[Cc]3%[Bb]6%[Cc]3%[Bb]6\z} parses "/föö", "/f%C3%B6%C3%B6", {} converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/foo/bar", "foo" == "foo", "bar" == "bar" converts "/hello/:person", %r{\A/hello/([^/?#]+)\z} parses "/hello/:person", "/hello/Frank", "person" == "Frank" converts "/?:fo oo?/?:bar?", %r{\A/?([^/?#]+)?/?([^/?#]+)?\z} parses "/?:foo?/?:bar?", "/hello/world", "foo" == "hello", "bar" == "world" parses "/?:foo?/?:bar?", "/hello", "foo" == "hello", "bar" == nil parses "/?:foo?/?:bar?", "/", "foo" == nil, "bar" == nil parses "/?:foo?/?:bar?", "", "foo" == nil, "bar" == nil converts "/*", %r{\A/(.*?)\z} parses "/*", "/", "splat" == "" parses "/*", "/foo", "splat" == "foo" parses "/*", "/foo/bar", "splat" == "foo/bar" converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/foo/bar/baz", "foo" == "foo", "splat" == "bar/baz z" converts "/:foo/:bar", %r{\A/([^/?#]+)/([^/?#]+)\z} parses "/:foo/:bar", "/user@example.com/name", "foo" == "user@example.com", "bar" == "name" converts "/test$/", %r{\A/test(?:\$|%24)/\z} parses "/test$/", "/test$/", {} converts "/te+st/", %r{\A/te(?:\+|%2[Bb])st/\z} parses "/te+st/", "/te+st/", {} fails "/te+st/", "/test/" fails "/te+st/", "/teeest/" converts "/test(bar)/", %r{\A/test(?:\(|%28)bar(?:\)|%29)/\z} parses "/test(bar)/", "/test(bar)/", {} converts "/path with spaces", %r{\A/path(?:%20|(?:\+|%2[Bb]))with(?:%20|(?:\+|%2[Bb]))spaces\z} parse es "/path with spaces", "/path%20with%20spaces", {} parses "/path with spaces", "/path%2Bwith%2Bspaces", {} parses "/path with spaces", "/path+with+spaces", {} converts "/foo&bar", %r{\A/foo(?:&|%26)bar\z} parses "/foo&bar", "/foo&bar", {} converts "/:foo/*", %r{\A/([^/?#]+)/(.*?)\z} parses "/:foo/*", "/hello%20world/how%20are%20you", "foo" == "hello%20world", "splat" == "how%20are%20you" converts "/*/foo/*/*", %r{\A/(.*?)/foo/(.*?)/(.*?)\z} parses "/*/foo/*/*", "/bar/foo/bling/baz/boom", "splat" == ["bar", "bling", "baz/boom"] fails "/*/foo/*/*", "/bar/f foo/baz" converts "/test.bar", %r{\A/test(?:\.|%2[Ee])bar\z} parses "/test.bar", "/test.bar", {} fails "/test.bar", "/test0bar" converts "/:file.:ext", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)\z} parses "/:file.:ext", "/pony.jpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%2Ejpg", "file" == "pony", "ext" == "jpg" fails "/:file.:ext", "/.jpg" converts "/:name.?:format?", %r{\A/((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)(?:\.|%2[Ee])?((?:[^\./?#%]|(?:%[^2].|%[2][^Ee]))+)?\z} parses "/:name.?: :format?", "/foo", "name" == "foo", "format" == nil parses "/:name.?:format?", "/foo.bar", "name" == "foo", "format" == "bar" parses "/:name.?:format?", "/foo%2Ebar", "name" == "foo", "format" == "bar" fails "/:name.?:format?", "/.bar" converts "/:user@?:host?", %r{\A/((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)(?:@|%40)?((?:[^@/?#%]|(?:%[^4].|%[4][^0]))+)?\z} parses "/:user@?:host?", "/foo@bar", "user" == "foo", "host" == "bar" parses "/:user@?:host?", "/foo.foo@bar", "user" == "foo.foo", "host" == "bar" parses "/:user@?:host?", "/foo@bar.bar", "user" == "foo", " "host" == "bar.bar" # From https://gist.github.com/2154980#gistcomment–169469. # # converts "/:name(.:format)?", %r{\A/([^\.%2E/?#]+)(?:\(|%28)(?:\.|%2E)([^\.%2E/?#]+)(?:\)|%29)?\z} # parses "/:name(.:format)?", "/foo", "name" == "foo", "format" == nil # parses "/:name(.:format)?", "/foo.bar", "name" == "foo", "format" == "bar" fails "/:name(.:format)?", "/foo." parses "/:id/test.bar", "/3/test.bar", {"id" == "3"} parses "/:id/test.bar", "/2/test.bar", {"id" == "2"} parses "/:id/test.bar", "/2E/test.bar", {"id" == "2E"} parses "/:id/test.bar", "/2e/test.b bar", {"id" == "2e"} fails "/:id/test.bar", "/%2E/test.bar" parses "/:file.:ext", "/pony%2ejpg", "file" == "pony", "ext" == "jpg" parses "/:file.:ext", "/pony%E6%AD%A3%2Ejpg", "file" == "pony%E6%AD%A3", "ext" == "jpg" parses "/:file.:ext", "/pony%e6%ad%a3%2ejpg", "file" == "pony%e6%ad%a3", "ext" == "jpg" parses "/:file.:ext", "/pony正%2Ejpg", "file" == "pony正", "ext" == "jpg" parses "/:file.:ext", "/pony正%2ejpg", "file" == "pony正", "ext" == "jpg" fails "/:file.:ext", "/pony正..jpg" fails "/:file.:ext", "/pony正.%2ejpg" end # Copyright (c) 2009 Damian Janowsk ki and Michel Martens for Citrusbyte # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included i in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. require "test/unit" # Test: ::Unit loads a default test if the suite is empty, whose purpose is to # fail. Since having empty contexts is a common practice, we decided to # overwrite TestSuite#empty? in order to allow them. Having a failure when no # tests have been defined seems counter–intuitive. class Test::Unit::TestSuite def empty? false end end # Contest adds +teardown+, +test+ and +context+ as class methods, and the # instance methods +setup+ and +teardown+ now iterate on the corresponding # blocks. Note that all setup and teardown blocks must be defined with the # block synt tax. Adding setup or teardown instance methods defeats the purpose # of this library. class Test::Unit::TestCase def self.setup(&block) setup_blocks << block end def self.teardown(&block) teardown_blocks block end def self.setup_blocks() @setup_blocks ||= [] end def self.teardown_blocks() @teardown_blocks ||= [] end def setup_blocks(base = self.class) setup_blocks base.superclass if base.superclass.respond_to? :setup_blocks base.setup_blocks.each do |block| instance_eval(&block) end end def teardown_blocks(base = self.class) teardown_blocks base.superc class if base.superclass.respond_to? :teardown_blocks base.teardown_blocks.each do |block| instance_eval(&block) end end alias setup setup_blocks alias teardown teardown_blocks def self.context(*name, &block) subclass = Class.new(self) remove_tests(subclass) subclass.class_eval(&block) if block_given? const_set(context_name(name.join(" ")), subclass) end def self.test(name, &block) define_method(test_name(name), &block) end class << self alias_method :should, :test alias_method :describe, :context end private def self.context_name(name) # "Test#{sanitize_ _name(name).gsub(/(^| )(\w)/) { $2.upcase }}".to_sym name = "Test#{sanitize_name(name).gsub(/(^| )(\w)/) { $2.upcase }}" name.tr(" ", "_").to_sym end def self.test_name(name) "test_#{sanitize_name(name).gsub(/\s+/,'_')}".to_sym end def self.sanitize_name(name) # name.gsub(/\W+/, ' ').strip name.gsub(/\W+/, ' ') end def self.remove_tests(subclass) subclass.public_instance_methods.grep(/^test_/).each do |meth| subclass.send(:undef_method, meth.to_sym) end end end require File.expand_path('../helper', __FILE__) begin require 'creole' class CreoleTest < Test: ::Unit::TestCase def creole_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline creole strings' do creole_app { creole '= Hiya' } assert ok? assert_body " h1=Hiya /h1=" end it 'renders .creole files in views path' do creole_app { creole :hello } assert ok? assert_body "<h1=Hello From Creole</h1=" end it "raises error if template not found" do mock_app { get('/') { creole :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "renders with inline layouts" do mock_app do la ayout { 'THIS. IS. #{yield.upcase}!' } get('/') { creole 'Sparta', :layout_engine == :str } end get '/' assert ok? assert_like 'THIS. IS. <P=SPARTA</P=!', body end it "renders with file layouts" do creole_app do creole 'Hello World', :layout == :layout2, :layout_engine == :erb end assert ok? assert_body "ERB Layout!\n<p=Hello World</p=" end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "hi" } template(:outer) { "<outer=<%= creole :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_li ike '<outer=<p=hi</p=</outer=', body end end rescue LoadError warn "#{$!.to_s}: skipping creole tests" end require File.expand_path('../helper', __FILE__) class DelegatorTest < Test::Unit::TestCase class Mirror attr_reader :last_call def method_missing(*a, &b) @last_call = [*a.map(&:to_s)] @last_call b if b end end def self.delegates(name) it "delegates #{name}" do m = mirror { send name } assert_equal [name.to_s], m.last_call end it "delegates #{name} with arguments" do m = mirror { send name, "foo", "bar" } assert_equal [name.to_s, "foo", "bar"], m.l last_call end it "delegates #{name} with block" do block = proc { } m = mirror { send(name, &block) } assert_equal [name.to_s, block], m.last_call end end setup do @target_was = Sinatra::Delegator.target end def teardown Sinatra::Delegator.target = @target_was end def delegation_app(&block) mock_app { Sinatra::Delegator.target = self } delegate(&block) end def mirror(&block) mirror = Mirror.new Sinatra::Delegator.target = mirror delegate(&block) end def delegate(&block) assert Sinatra::Delegator.target != Sinatra::Application Object.new.extend(Sinatra::De elegator).instance_eval(&block) if block Sinatra::Delegator.target end def target Sinatra::Delegator.target end it 'defaults to Sinatra::Application as target' do assert_equal Sinatra::Application, Sinatra::Delegator.target end %w[get put post delete options patch].each do |verb| it "delegates #{verb} correctly" do delegation_app do send(verb, '/hello') { 'Hello World' } end request = Rack::MockRequest.new(@app) response = request.request(verb.upcase, '/hello', {}) assert response.ok? assert_equal 'Hello World', response.body end end it "delegates head co orrectly" do delegation_app do head '/hello' do response['X–Hello'] = 'World!' 'remove me' end end request = Rack::MockRequest.new(@app) response = request.request('HEAD', '/hello', {}) assert response.ok? assert_equal 'World!', response['X–Hello'] assert_equal '', response.body end it "registers extensions with the delegation target" do app, mixin = mirror, Module.new Sinatra.register mixin assert_equal ["register", mixin.to_s], app.last_call end it "registers helpers with the delegation target" do app, mixin = mirror, Module.new Sinatra.helpers mixin as ssert_equal ["helpers", mixin.to_s], app.last_call end it "registers middleware with the delegation target" do app, mixin = mirror, Module.new Sinatra.use mixin assert_equal ["use", mixin.to_s], app.last_call end it "should work with method_missing proxies for options" do mixin = Module.new do def respond_to?(method, *) method.to_sym == :options or super end def method_missing(method, *args, &block) return super unless method.to_sym == :options {:some == :option} end end value = nil mirror do extend mixin value = options end assert_equal({:some == :option n}, value) end it "delegates crazy method names" do Sinatra::Delegator.delegate "foo:bar:" method = mirror { send "foo:bar:" }.last_call.first assert_equal "foo:bar:", method end delegates 'get' delegates 'patch' delegates 'put' delegates 'post' delegates 'delete' delegates 'head' delegates 'options' delegates 'template' delegates 'layout' delegates 'before' delegates 'after' delegates 'error' delegates 'not_found' delegates 'configure' delegates 'set' delegates 'mime_type' delegates 'enable' delegates 'disable' delegates 'use' delegates 'development?' de elegates 'test?' delegates 'production?' delegates 'helpers' delegates 'settings' end # encoding: UTF–8 require File.expand_path('../helper', __FILE__) require 'erb' class BaseTest < Test::Unit::TestCase setup do @base = Sinatra.new(Sinatra::Base) @base.set :views, File.dirname(__FILE__) + "/views" end it 'allows unicode strings in ascii templates per default (1.9)' do next unless defined? Encoding @base.new!.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value == "åkej") end it 'allows ascii strings in unicode templates per default (1.9) )' do next unless defined? Encoding @base.new!.erb(:utf8, {}, :value == "Some Lyrics".encode("ASCII")) end end require File.expand_path('../helper', __FILE__) class ERBTest < Test::Unit::TestCase def engine Tilt::ERBTemplate end def setup Tilt.prefer engine, :erb super end def erb_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'uses the correct engine' do assert_equal engine, Tilt[:erb] end it 'renders inline ERB strings' do erb_app { erb '<%= 1 + 1 %=' } assert ok? assert_equal '2', body end it ' 'renders .erb files in views path' do erb_app { erb :hello } assert ok? assert_equal "Hello World\n", body end it 'takes a :locals option' do erb_app do locals = {:foo == 'Bar'} erb '<%= foo %=', :locals == locals end assert ok? assert_equal 'Bar', body end it "renders with inline layouts" do mock_app do layout { 'THIS. IS. <%= yield.upcase %=!' } get('/') { erb 'Sparta' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "renders with file layouts" do erb_app { erb 'Hello World', :layout == :layout2 } assert ok? assert_body "ERB Layout t!\nHello World" end it "renders erb with blocks" do mock_app do def container @_out_buf << "THIS." yield @_out_buf << "SPARTA!" end def is; "IS." end get('/') { erb '<% container do %= %= is %= % end %=' } end get '/' assert ok? assert_equal 'THIS. IS. SPARTA!', body end it "can be used in a nested fashion for partials and whatnot" do mock_app do template(:inner) { "<inner=<%= 'hi' %=</inner=" } template(:outer) { "<outer=<%= erb :inner %=</outer=" } get('/') { erb :outer } end get '/' assert ok? assert_equal '<outer=<inner=hi</inner=</outer=', body en ndendbeginrequire'erubis'classErubisTest<ERBTestdefengine;Tilt::ErubisTemplateendendrescueLoadErrorwarn"#{$!.to_s}:skippingerubistests"endrequireFile.expand_path('../helper',__FILE__)classExtensionsTest Test::Unit::TestCasemoduleFooExtensionsdeffooendprivatedefim_hiding_in_ur_foosendendmoduleBarExtensionsdefbarendendmoduleBazExtensionsdefbazendendmoduleQuuxExtensionsdefquuxendendmodulePainExtensionsdeffoo=(name);enddefbar?(name);enddeffizz!(name);endendit'willaddthemethodstotheDSL L for the class in which you register them and its subclasses' do Sinatra::Base.register FooExtensions assert Sinatra::Base.respond_to?(:foo) Sinatra::Application.register BarExtensions assert Sinatra::Application.respond_to?(:bar) assert Sinatra::Application.respond_to?(:foo) assert !Sinatra::Base.respond_to?(:bar) end it 'allows extending by passing a block' do Sinatra::Base.register { def im_in_ur_anonymous_module; end } assert Sinatra::Base.respond_to?(:im_in_ur_anonymous_module) end it 'will make sure any public methods added via Application#register r are delegated to Sinatra::Delegator' do Sinatra::Application.register FooExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo) assert !Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:im_hiding_in_ur_foos) end it 'will handle special method names' do Sinatra::Application.register PainExtensions assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:foo=) assert Sinatra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:bar?) assert Sinatr ra::Delegator.private_instance_methods. map { |m| m.to_sym }.include?(:fizz!) end it 'will not delegate methods on Base#register' do Sinatra::Base.register QuuxExtensions assert !Sinatra::Delegator.private_instance_methods.include?("quux") end it 'will extend the Sinatra::Application application by default' do Sinatra.register BazExtensions assert !Sinatra::Base.respond_to?(:baz) assert Sinatra::Application.respond_to?(:baz) end module BizzleExtension def bizzle bizzle_option end def self.registered(base) fail "base should be BizzleApp" unless base == Biz zzleApp fail "base should have already extended BizzleExtension" unless base.respond_to?(:bizzle) base.set :bizzle_option, 'bizzle!' end end class BizzleApp < Sinatra::Base end it 'sends .registered to the extension module after extending the class' do BizzleApp.register BizzleExtension assert_equal 'bizzle!', BizzleApp.bizzle_option assert_equal 'bizzle!', BizzleApp.bizzle end end require File.expand_path('../helper', __FILE__) class BeforeFilterTest < Test::Unit::TestCase it "executes filters in the order defined" do count = 0 mock_app do get('/') { 'He ello World' } before do assert_equal 0, count count = 1 end before do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "can modify the request" do mock_app do get('/foo') { 'foo' } get('/bar') { 'bar' } before { request.path_info = '/bar' } end get '/foo' assert ok? assert_equal 'bar', body end it "can modify instance variables available to routes" do mock_app do before { @foo = 'bar' } get('/foo') { @foo } end get '/foo' assert ok? assert_equal 'bar', body end it "allows redirects" d do mock_app do before { redirect '/bar' } get('/foo') do fail 'before block should have halted processing' 'ORLY?!' end end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do before { 'Hello World!' } get('/foo') do assert_equal [], response.body 'cool' end end get '/foo' assert ok? assert_equal 'cool', body end it "does modify the response with halt" do mock_app do before { halt 302, 'Hi' } get '/foo' do "should not happen n" end end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "gives you access to params" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=cool' assert ok? assert_equal 'cool', body end it "properly unescapes parameters" do mock_app do before { @foo = params['foo'] } get('/foo') { @foo } end get '/foo?foo=bar%3Abaz%2Fbend' assert ok? assert_equal 'bar:baz/bend', body end it "runs filters defined in superclasses" do base = Class.new(Sinatra::Base) base.before { @foo = 'hello from superclass' }
 mock_app(base) { get('/foo') { @foo } } get '/foo' assert_equal 'hello from superclass', body end it 'does not run before filter when serving static files' do ran_filter = false mock_app do before { ran_filter = true } set :static, true set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do before("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_fil
lter get '/bar' assert ran_filter end it 'generates block arguments from route pattern' do subpath = nil mock_app do before("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end end class AfterFilterTest < Test::Unit::TestCase it "executes before and after filters in correct order" do invoked = 0 mock_app do before { invoked = 2 } get('/') { invoked += 2; 'hello' } after { invoked *= 2 } end get '/' assert ok? assert_equal 8, invoked end it "executes filters in the order defined" do count = 0 mock_app do get
t('/') { 'Hello World' } after do assert_equal 0, count count = 1 end after do assert_equal 1, count count = 2 end end get '/' assert ok? assert_equal 2, count assert_equal 'Hello World', body end it "allows redirects" do mock_app do get('/foo') { 'ORLY' } after { redirect '/bar' } end get '/foo' assert redirect? assert_equal 'http://example.org/bar', response['Location'] assert_equal '', body end it "does not modify the response with its return value" do mock_app do get('/foo') { 'cool' } after { 'Hello World!' } end get '/foo' assert ok? assert_equal 'c
cool', body end it "does modify the response with halt" do mock_app do get '/foo' do "should not be returned" end after { halt 302, 'Hi' } end get '/foo' assert_equal 302, response.status assert_equal 'Hi', body end it "runs filters defined in superclasses" do count = 2 base = Class.new(Sinatra::Base) base.after { count *= 2 } mock_app(base) do get('/foo') do count += 2 "ok" end end get '/foo' assert_equal 8, count end it 'does not run after filter when serving static files' do ran_filter = false mock_app do after { ran_filter = true } set :static, true s
set :public_folder, File.dirname(__FILE__) end get "/#{File.basename(__FILE__)}" assert ok? assert_equal File.read(__FILE__), body assert !ran_filter end it 'takes an optional route pattern' do ran_filter = false mock_app do after("/b*") { ran_filter = true } get('/foo') { } get('/bar') { } end get '/foo' assert !ran_filter get '/bar' assert ran_filter end it 'changes to path_info from a pattern matching before filter are respoected when routing' do mock_app do before('/foo') { request.path_info = '/bar' } get('/bar') { 'blah' } end get '/foo' assert ok?
 assert_equal 'blah', body end it 'generates block arguments from route pattern' do subpath = nil mock_app do after("/foo/:sub") { |s| subpath = s } get('/foo/*') { } end get '/foo/bar' assert_equal subpath, 'bar' end it 'is possible to access url params from the route param' do ran = false mock_app do get('/foo/*') { } before('/foo/:sub') do assert_equal params[:sub], 'bar' ran = true end end get '/foo/bar' assert ran end it 'is possible to apply host_name conditions to before filters with no path' do ran = false mock_app do before(:host_name == 'example
e.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to before filters with a path' do ran = false mock_app do before('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possibl
le to apply host_name conditions to after filters with no path' do ran = false mock_app do after(:host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.org' }) assert !ran get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply host_name conditions to after filters with a path' do ran = false mock_app do after('/foo', :host_name == 'example.com') { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_HOST' == 'example.com' }) assert !ran get('/foo', {}, { 'HTTP_H
HOST' == 'example.org' }) assert !ran get('/foo', {}, { 'HTTP_HOST' == 'example.com' }) assert ran end it 'is possible to apply user_agent conditions to before filters with no path' do ran = false mock_app do before(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to before filters with a path' do ran = false mock_app do before('/foo', :user_agent == /foo/) { ran = true } get('/'
') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'can add params' do mock_app do before { params['foo'] = 'bar' } get('/') { params['foo'] } end get '/' assert_body 'bar' end it 'can remove params' do mock_app do before { params.delete('foo') } get('/') { params['foo'].to_s } end get '/?foo=bar' assert_body '' end it 'is possible to apply user_agent conditions to after filters with no path' do ran = fal
lse mock_app do after(:user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran end it 'is possible to apply user_agent conditions to after filters with a path' do ran = false mock_app do after('/foo', :user_agent == /foo/) { ran = true } get('/') { 'welcome' } end get('/', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'bar' }) assert !ran get('/foo', {}, { 'HTTP_USER_AGENT' == 'foo' }) assert ran
 end it 'only triggeres provides condition if conforms with current Content–Type' do mock_app do before(:provides == :txt) { @type = 'txt' } before(:provides == :html) { @type = 'html' } get('/') { @type } end get('/', {}, { 'HTTP_ACCEPT' == '*' }) assert_body 'txt' end end require File.expand_path('../helper', __FILE__) begin require 'haml' class HAMLTest < Test::Unit::TestCase def haml_app(&block) mock_app do set :views, File.dirname(__FILE__) + '/views' get('/', &block) end get '/' end it 'renders inline HAML strings' do haml_app { haml '%h1 Hiya' } as
ssert ok? assert_equal "<h1=Hiya</h1=\n", body end it 'renders .haml files in views path' do haml_app { haml :hello } assert ok? assert_equal "<h1=Hello From Haml</h1=\n", body end it "renders with inline layouts" do mock_app do layout { %q(%h1= 'THIS. IS. ' + yield.upcase) } get('/') { haml '%em Sparta' } end get '/' assert ok? assert_equal "<h1=THIS. IS. <EM=SPARTA</EM=</h1=\n", body end it "renders with file layouts" do haml_app { haml 'Hello World', :layout == :layout2 } assert ok? assert_equal "<h1=HAML Layout!</h1=\n<p=Hello World</p=\n", body end i
it "raises error if template not found" do mock_app { get('/') { haml :no_such_template } } assert_raise(Errno::ENOENT) { get('/') } end it "passes HAML options to the Haml engine" do mock_app { get('/') { haml "!!!\n%h1 Hello World", :format == :html5 } } get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", body end it "passes default HAML options to the Haml engine" do mock_app do set :haml, {:format == :html5} get('/') { haml "!!!\n%h1 Hello World" } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1=Hello World</h1=\n", bo
ody end it "merges the default HAML options with the overrides and passes them to the Haml engine" do mock_app do set :haml, {:format == :html5, :attr_wrapper == '"'} # default HAML attr are <tag attr='single–quoted'= get('/') { haml "!!!\n%h1{:class == :header} Hello World" } get('/html4') { haml "!!!\n%h1{:class == 'header'} Hello World", :format == :html4 } end get '/' assert ok? assert_equal "<!DOCTYPE html=\n<h1 class=\"header\"=Hello World</h1=\n", body get '/html4' assert ok? assert_match(/^<!DOCTYPE html PUBLIC (.*) HTML 4.01/, body) end it "is po
ossible to pass locals" do haml_app { haml "= foo", :locals == { :foo == 'bar' }} assert_equal "bar\n", body end end rescue LoadError warn "#{$!.to_s}: skipping haml tests" end
